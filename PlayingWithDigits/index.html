<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>task7</title>
</head>

<body>
    <pre>
        Some numbers have funny properties. For example:
        89 --> 8¹ + 9² = 89 * 1
        695 --> 6² + 9³ + 5⁴= 1390 = 695 * 2
        46288 --> 4³ + 6⁴+ 2⁵ + 8⁶ + 8⁷ = 2360688 = 46288 * 51
        Given a positive integer n written as abcd... (a, b, c, d... being digits) and a positive integer p
        we want to find a positive integer k, if it exists, such that the sum of the digits of n taken to the successive powers of p is equal to k * n.
        In other words:
        Is there an integer k such as : (a ^ p + b ^ (p+1) + c ^(p+2) + d ^ (p+3) + ...) = n * k
        If it is the case we will return k, if not return -1.
        Note: n and p will always be given as strictly positive integers.
        digPow(89, 1) should return 1 since 8¹ + 9² = 89 = 89 * 1
        digPow(92, 1) should return -1 since there is no k such as 9¹ + 2² equals 92 * k
        digPow(695, 2) should return 2 since 6² + 9³ + 5⁴= 1390 = 695 * 2
        digPow(46288, 3) should return 51 since 4³ + 6⁴+ 2⁵ + 8⁶ + 8⁷ = 2360688 = 46288 * 51

    </pre>
    <script>
        function digPow(n, p) {
            let arr = String(n).split("");
            let sum = 0;
            for (let i = 0; i < arr.length; i++) {
                sum += Math.pow(arr[i], p++);
            }

            if (n > sum) {
                return -1;
            } else if (sum % n === 0) {
                return sum / n;
            } else {
                return -1;
            }
        }
        console.log(digPow(89, 1)); //, 1)
        console.log(digPow(92, 1)); //, -1)
        console.log(digPow(46288, 3)); //, 51)
    </script>
</body>

</html>